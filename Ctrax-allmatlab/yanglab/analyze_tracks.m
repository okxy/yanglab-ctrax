%% analyze_tracks

% script that analyzes Ctrax trajectories
%
% 18 Oct 2011 by Ulrich Stern
%
% notes:
% * requires trx to be set
% * fields added to trx
% *   YL_matname: name of Ctrax MAT-file
% * yanglab: Automated Tracking Analysis has details on some of the calculations
% * parts of early version inspired by convert_units

function analyze_tracks

% retrieve from base namespace
if evalin('base', 'exist(''YL'')')
  YL = evalin('base', 'YL');
end
trx = evalin('base', 'trx');

% - - - possibly customize the following - - -

% whether to flip y values
%  Ctrax flips y values in MAT-file, e.g., for M-JPEG (see yanglab: Ctrax Bugs)
flipY = true;

% frames per second
fps = 7.5;

% for plot with chamber image in background
colors = char('.g', '.w', '.m');   % top, middle, bottom
  % note: g=green, w=white, m=magenta, r=red (see MATLAB LineSpec)
plotFrames = 5000;   % 0 for all

% number of periods (intervals of equal size)
numPeriods = 8;   % 0 for none; 8 gives 1h periods for 8h videos

% by egg before egg-laying analysis
skipBeforeEggLayingAnalysis = true;
beforeEggS = 60;   % number of seconds to analyze before each egg
showVisits = 10;   % number of visits to top or bottom regions to show
                   %  (visits shown only if egg file and intervals given)

% whether to show plots with y positions over time
%  (plots also turned on by setting YL.plotTitle)
showYPosPlots = false;
showReturnPoints = false;   % if "before egg-laying analysis" is enabled, for
                            %  eggs only; otherwise, all return points
closeBorderDistanceFraction = 0.125;   % return considered "close" if within this
                                       %  fraction of border distance

% by egg before border crossing analysis
%  stats: number of visits to top and bottom and average duration of visits
%  plot:  y position over time
numControlsForStats = 20;   % stats: number of controls
beforeXingStatsS = 60;      %        number of seconds before crossing to analyze
numControlsForPlot = 100;   % plot: number of controls
beforeXingPlotS = 10;       %       number of seconds before crossing to plot

% middle crossings before egg-laying
plotMiddleXings = false;
maxPreELDelay = 20;   % max. number of seconds between border crossing and egg-laying
                      %  for middle region crossing times to be calculated

% returns before eggs analysis
returnsBeforeEggS = 60;   % number of seconds to analyze before each egg
minEggDistanceS = 90;     % minimum temporal distance to previous egg

% to customize plots
xTickDeltaM = 0;   % egg-laying times plot: if non-0, delta (in min) between x ticks
                   %  (if 0, delta is 1/8 of the length of the video)

% fly jumps -- primarily for assessing shadow detector
plotJumps = true;
onlySuspicious = true;
autoFix = true;   % requires plotJumps
showFixed = false;

% low vs. high speed
speedCalc = false;   % whether to do speed calc
speedCalcS = 60;    % number of seconds to calculate speed over
speedTh = 1.3;      % threshold (unit: pixel distance / frame)

% "on substrate" thresholds for major and minor axes-derived values
abMin = 2.1;   % a/b  [original: 2]
bMax = 2.6;    % b; best to learn this value [original: 2.5]
writeSubsFile = false;   % whether to write "on substrate" file

% file with map from Ctrax MAT-file name to image/movie name and border points
useMatMapFile = false;
matMapFile = '__matMap.MAT';

% whether to use default image (generated by Avidemux)
useDefaultImage = true;

% whether to use template matching
useTemplateMatching = true;

% support for "non-standard" chambers
longChamber = false;

% for customizing looks for certain papers
sucrosePaper = false;
uvPaper = false;
uvOnTop = false;

% - - - end customize - - -

debug = false;

efname = '';
REGIONS = {'top', 'middle', 'bottom'};


%% common
nflies = length(trx);
warnings = {};

%% trx check and preprocessing
trxLs = arrayfun(@(e) length(e.x), trx);
if min(trxLs) ~= max(trxLs)
  error('trajectory lengths differ (possibly due to tracking error)');
end
trxL = trxLs(1);

%% varying background
[onIvs, isOn] = onIntervals();

%% check whether MAT-file was previously analyzed
% if yes, image/movie name and border points are known
if exist(matMapFile, 'file') && useMatMapFile
  load(matMapFile);
else
  matMap = containers.Map();
end
matname = '';
if isfield(trx, 'YL_matname')
  matname = trx(1).YL_matname;
end
matInfo = struct;
if isKey(matMap, matname)
  matInfo = matMap(matname);
else
  matInfo.moviename = '';
end

%% get name for movie or image file
moviename = '';
% default image
imgname = '';
if matname
  imgname = regexprep(matname, '\\c(\d)__', '\\p$1__');
  imgname = regexprep(imgname, ' AD\.mat$', '.jpg');
  if strcmp(matname, imgname)
    imgname = '';
  end
end
if matInfo.moviename
  moviename = matInfo.moviename;
elseif useDefaultImage && ~isempty(imgname) && exist(imgname, 'file')
  moviename = imgname;
else
  if isfield(trx, 'moviename') && exist(trx(1).moviename, 'file'),
    moviename = trx(1).moviename;
  end
  [moviename, moviepath] = uigetfilehelp({'*.jpg', '*.avi', '*.fmf', '*.sbfmf', ...
    '*.wmv'}', 'Choose movie or image', moviename);
  moviename = [moviepath, moviename];
  if moviepath
    [trx(1).moviename, matInfo.moviename] = deal(moviename);
  end
end
if ~ischar(moviename) || ~exist(moviename, 'file')
  error('no file to read image from');
end

%% egg file
efpath = regexp(moviename, '^.*\\', 'match');
efpath = choice(~isempty(efpath), efpath{1}, '');
[efname, efpath] = uigetfilehelp('*.txt', 'Choose an egg file (optional)', [efpath, efname]);
eggfile = ~(isnumeric(efname) && efname == 0);
if eggfile
  fprintf('egg file: %s\n', efname);
end
fprintf('\n');

%% try to match template
match = false;
if useTemplateMatching
  [match, bx, by, sapx, sapy] = matchTemplate();
end

%% read image and plot it
if regexp(moviename, '\.jpg$')
  im = imread(moviename);
else
  [readframe, nframes] = getReadframe(moviename);
  im = readframe(round(nframes/2));
end
imBT = convertImage(im);
figure('Name', 'Borders and trajectories');
clf; imagesc(imBT); axis image; colormap gray; hax = gca; hold on;

%% y and theta value preparation
% note: requires image
if flipY && ~isfield(trx, 'YL_y_flipped')
  height1 = size(imBT, 1) + 1;
  for f = 1:nflies
    trx(f).y = height1 - trx(f).y;
    trx(f).theta = - trx(f).theta;
  end
  trx(1).YL_y_flipped = 1;
end
for f = 1:nflies
  trx(f).YL_y_min_max = [min(trx(f).y), max(trx(f).y)];
end

%% order flies increasing x (left to right)
% note: this should happen after reading, e.g., trx(1).YL_matname
firstXs = arrayfun(@(e) e.x(1), trx);
[~, flySortOrder] = sort(firstXs);
trx = trx(flySortOrder);

if speedCalc
  spd = speed();
end

%% get border points
% if a fifth point is given, chamber separator crossing check will be performed using this point
if match
  % bx, by set above
elseif isfield(matInfo, 'borders')
  bx = matInfo.borders(:,1);
  by = matInfo.borders(:,2);
else
  title({'Click on two points to define the first border, then two points for the second border.', ...
      'Press Enter when done.'});
  [bx, by] = getpts(hax);
  matInfo.borders = [bx, by];
  if matname
    matMap(matname) = matInfo;
    save(matMapFile, 'matMap');
  end
end

%% orient
% upper left corner has coordinates [0, 0] in Matlab
% orient each border line so that x coordinates are decreasing
%  previously: vertical (left, right) borders, y coordinates increasing
B = [bx, by]';   % each border point is a column vector
  % top border: points 1 and 2, bottom border: points 3 and 4
  % points for top border currently must be given first
for p=1:2:3
  if B(1,p) < B(1,p+1)
    B(:,[p,p+1]) = B(:,[p+1,p]);
  end
end
B12 = B(:,2)-B(:,1);   % note: 12: from 1 to 2
B34 = B(:,4)-B(:,3);

%% chamber separator
sep = choice(length(bx) > 4, bx(5), 0);
yB = [mean(B(2,[1:2])), mean(B(2,[3:4]))];

fprintf('analyzing tracks...\n\n');

%% plot jumps and possibly fix them
% note: requires sep to be set
if plotJumps
  plotFlyJumps();
end

%% plot border etc.
fN = '';
if plotFrames > 0
  fN = sprintf(' for the first %.1f minutes (%d frames)', frame2m(plotFrames), plotFrames);
end
title(sprintf('Borders used and trajectories%s', fN));
plot(bx(1:2), by(1:2), 'Y', bx(3:4), by(3:4), 'Y');

%% substrate area polygons
% users specifies 6 points for each polygon, first and last point are projected to border
%  required order of areas: TL (top left), TR, BL, BR
manualSubstrateAreas = length(bx) > 5;
substrateAreas = manualSubstrateAreas || exist('sapx', 'var') && ~isempty(sapx);
if substrateAreas
  if manualSubstrateAreas
    sapx = cell(nflies, 2);   % fly, top|bottom, points
    sapy = cell(nflies, 2);
  end
  for lr=0:1   % left, right
    f = lr+1;
    for tb=0:1   % top, bottom
      if manualSubstrateAreas
        BB = B(:, 1+2*tb);   % line to project to is BB + k*BD
        BD = B(:, 1+2*tb+1) - BB;
        for i=0:5   % for each given point
          pp = B(:,6+12*tb+6*lr+i);
          % project
          if i == 0 || i == 5
            ppp = BB + dot(pp-BB, BD) / dot(BD, BD) * BD;
            ppi = choice(i == 0, [1, 9], [8]);
            sapx{f,tb+1}(ppi) = ppp(1);
            sapy{f,tb+1}(ppi) = ppp(2);
          end
          sapx{f,tb+1}(2+i) = pp(1);
          sapy{f,tb+1}(2+i) = pp(2);
        end
      end
      plot(sapx{f,tb+1}, sapy{f,tb+1}, 'b');
    end
  end
else
  plotMiddleXings = false;   % temporary; current plot requires sapx, etc.
end

%% read egg file
if eggfile
  eis = readEggFile();
end

%% stats file
% for fields, see YL.header below
sfile = {};   % line of file; index: fly
statsFile = exist('YL') && isfield(YL, 'sf');

%% intervals for stats
% example: YL.ivs = [100 200; 0 230] for fly 1: 1:00-2:00, fly 2: 0:00-2:30
intervals = exist('YL') && isfield(YL, 'ivs') && ~isempty(YL.ivs);
intervalsS = '';
if intervals
  if size(YL.ivs, 1) ~= nflies
    error('ivs must have as many rows as there are flies');
  end
  ivsF = zeros(nflies, 2);   % intervals by frame
  for f=1:nflies
    iv = YL.ivs(f,:);
    if iv(1) > iv(2)
      error('interval start greater than end in ivs');
    end
    ivH = floor(iv./100);
    ivM = mod(iv, 100);
    if any(ivM > 59)
      error('minute value greater than 59 in ivs');
    end
    tM = frame2m(length(trx(f).x));
    if f > 1
      intervalsS = sprintf('%s, ', intervalsS);
    end
    intervalsS = sprintf('%sfly %d: %d:%02d - %d:%02d (%.1f%% of %.1fh)', ...
        intervalsS, f, ivH(1), ivM(1), ivH(2), ivM(2), ...
        ((ivH(2)-ivH(1))*60 + ivM(2)-ivM(1))/tM*100, tM/60);
    if statsFile
      sfile{f} = sprintf('%s,%s,%d:%02d,%d:%02d', ...
        YL.matFile, YL.fly12(f), ivH(1), ivM(1), ivH(2), ivM(2));
    end
    ivsF(f, :) = (ivH.*60 + ivM) .* (60*fps) + 1;
  end
  fprintf('intervals: %s\n\n', intervalsS);
end

%% periods for stats
if numPeriods
  fprintf('analyzing by period (%d periods)\n\n', numPeriods);
end

%% analyze
% note: the ivD dimension below has these values: all(1)| pre iv|in iv|post iv| on|off| period 1|...
tic;
nd2 = 4 + 2 + numPeriods;
stats.nframes = zeros(nflies, nd2, 5);   % fly, ivD, region (top, middle, bottom, substrate top, substrate bottom)
stats.ncross = zeros(nflies, nd2, 4);    % fly, ivD, border (top, bottom, middle region, substrate-to-substrate)
stats.nsep = zeros(nflies, 1);           % chamber separator crossings (Ctrax bug)
sepFrames = {};                          % fly, separator crossing frames
onSubs = {};                             % fly, whether on substrate for all inSap cases

% border crossings (top, bottom, and middle region)
% note: fi can also be boolean array to select frames
function tbmr = ncross(btxis, bbxis, mrxis, fi, li)
  if isscalar(fi)
    inFL = @(idxs) nnz((fi <= idxs) .* (idxs <= li));
    tbmr = [inFL(btxis), inFL(bbxis), ...
      nnz((fi <= squeeze(mrxis(1,:))) .* (squeeze(mrxis(2,:)) <= li))];
  else
    assert(~exist('li', 'var'));
    tbmr = [nnz(fi(btxis)), nnz(fi(bbxis)), nnz(fi(mrxis(1,:)) .* fi(mrxis(2,:)))];
  end
end
% number of frames for regions 1, 2, 3
nfr = @(r) [nnz(r == 1), nnz(r == 2), nnz(r == 3)];

for f=1:nflies

  % determine regions (1: top, 2: middle, 3: bottom)
  [m1, m2] = deal([B12, -B(:,1)], [B34, -B(:,3)]);
  [m1, m2] = deal(m1(:,:,ones(1,trxL)), m2(:,:,ones(1,trxL)));
  xy = reshape([trx(f).x; trx(f).y], 2, 1, trxL);
  [m1(:,2,:), m2(:,2,:)] = deal(m1(:,2,:) + xy, m2(:,2,:) + xy);
  det = @(m) squeeze(m(1,1,:) .* m(2,2,:) - m(1,2,:) .* m(2,1,:))';
  [det1, det2] = deal(det(m1), det(m2));
  regs = ones(1,trxL) + (det1 < 0) + (det2 < 0);
  trx(f).YL_reg = regs;

  if substrateAreas
    inSap{f} = inpolygon(trx(f).x, trx(f).y, sapx{f,1}, sapy{f,1}) ...
      + inpolygon(trx(f).x, trx(f).y, sapx{f,2}, sapy{f,2});
    onSubstrateClassification(f);
  end

  % determine crossings
  pregs = [regs(1), regs(1:end-1)];
  bxis = find(regs ~= pregs);   % indexes of all border crossings
  bxs = @(b) bxis(logical((regs(bxis) == b) + (pregs(bxis) == b)));
  [btxis, bbxis] = deal(bxs(1), bxs(3));
    % indexes of top and bottom crossings
    % note: separate since both borders can be crossed for same frame
  mrxis = [];   % middle region crossings
  for i = 1:length(bxis)
    [fi, li] = deal(0, bxis(i));
    reg = regs(li);
    if reg == 2
      continue
    end
    if pregs(li) == 4 - reg
      fi = li - 1;
    elseif i > 1
      i1 = bxis(i-1);
      if pregs(i1) == 4 - reg
        fi = i1 - 1;
      end
    end
    if fi > 0
      mrxis = [mrxis, [fi; li]];
    end
  end

  % number of frames and crossings
  stats.nframes(f,1,1:3) = nfr(regs);
  stats.ncross(f,1,1:3) = ncross(btxis, bbxis, mrxis, 1, trxL);
  if intervals
    [fi, lis] = deal(1, [ivsF(f,:)-1, trxL]);
    for i = 1:3
      li = lis(i);
      stats.nframes(f,1+i,1:3) = nfr(regs(fi:li));
      stats.ncross(f,1+i,1:3) = ncross(btxis, bbxis, mrxis, fi, li);
      fi = li+1;
    end
  end
  if ~isempty(onIvs)
    offOn = {~isOn, isOn};
    for on = [true, false]
      stats.nframes(f,6-on,1:3) = nfr(regs(offOn{1+on}));
      stats.ncross(f,6-on,1:3) = ncross(btxis, bbxis, mrxis, offOn{1+on});
    end
  end
  if numPeriods
    for p = 1:numPeriods
      [fi, li] = p2fl(p, trxL);
      stats.nframes(f,6+p,1:3) = nfr(regs(fi:li));
      stats.ncross(f,6+p,1:3) = ncross(btxis, bbxis, mrxis, fi, li);
    end
  end

  % chamber separator crossing
  if sep > 0
    xls = trx(f).x < sep;
    pxls = [xls(1), xls(1:end-1)];
    chis = find(xls ~= pxls);
    stats.nsep(f) = length(chis);
    sepFrames{f} = chis - 1;
  end

  % plot
  li = min(trxL, (plotFrames == 0)*trxL + plotFrames);
  plot(trx(f).x(1:li), trx(f).y(1:li), 'w');
  if f == 1
    for reg = [1,3]
      if reg == 1
        [y, i] = min(trx(f).y);
        mm = 'min';
      else
        [y, i] = max(trx(f).y);
        mm = 'max';
      end
      rn = REGIONS{reg};
      if regs(i) ~= reg
        warn(sprintf('position with %s y not in region %s for fly 1', mm, rn));
      else
        text(10, y, rn, 'Color', 'y');
      end
    end
  end
end

if substrateAreas && writeSubsFile
  saveSubstrateClassification();
end
elapsedS = toc;
fprintf('analysis time: %.1fs\n\n', elapsedS);

%% print stats

% stats file header
if statsFile && YL.header
  fprintf(YL.sf, ['movie,control/experimental fly,interval start,end,', ...
    'percent time PA,middle,plain,', ...
    'percent time PA in interval,middle,plain,', ...
    'crossings middle region,crossings middle region in interval\n']);
end

inInv = choice(intervals, '  (pre interval | in | post)', '');
if ~isempty(onIvs)
  inInv = [inInv, '  (on | off)'];
end

function reportPercentTime(f, fi, li)
  fprintf('  (');
  for d2=fi:li
    nfI = sum(stats.nframes(f,d2,1:3));
    fprintf('%.1f %.1f %.1f', stats.nframes(f,d2,1:3) .* (100/nfI));
    if d2 < li
      fprintf(' | ');
    end
    if statsFile && d2 == 3
      sfile{f} = sprintf('%s,%.1f,%.1f,%.1f', sfile{f}, stats.nframes(f,d2,PAmP) .* (100/nfI));
    end
  end
  fprintf(')');
end
fprintf('percent of time in regions top, middle, and bottom%s  [number of frames, 1st x]:\n', inInv);
for f=1:nflies
  nf = sum(stats.nframes(f,1,1:3));
  fprintf('fly %d: %.1f %.1f %.1f', f, stats.nframes(f,1,1:3) .* (100/nf));
  if statsFile
    PAmP = [3 2 1];   % PA middle Plain
    if YL.topPA
      PAmP = [1 2 3];
    end
    sfile{f} = sprintf('%s,%.1f,%.1f,%.1f', sfile{f}, stats.nframes(f,1,PAmP) .* (100/nf));
  end
  if intervals
    reportPercentTime(f, 2, 4);
  end
  if ~isempty(onIvs)
    reportPercentTime(f, 5, 6);
  end
  fprintf('  [%d, %.0f]\n', nf, trx(f).x(1));
  if nf ~= length(trx(f).x)
    fprintf('  calculated number of frames differs from length of trx.x')
  end
end

if false && substrateAreas   % HACK
  fprintf('\npercent of time on substrate top and bottom%s:\n', inInv);
  for f=1:nflies
    nf = sum(stats.nframes(f,1,1:3));
    fprintf('fly %d: %.1f %.1f', f, stats.nframes(f,1,4:5) .* (100/nf));
    if intervals
      % note: this should possibly change to "for d2=2:4" (see above)
      nfI = sum(stats.nframes(f,3,1:3));
      fprintf('  (%.1f %.1f)', stats.nframes(f,3,4:5) .* (100/nfI));
    end
    fprintf('\n');
  end
end

function reportXings(f, fi, li)
  fprintf('  (');
  for d2=fi:li
    fprintf('%d %d  %d', stats.ncross(f,d2,1:3));
    if d2 < li
      fprintf(' | ');
    end
    if statsFile && d2 == 3
      sfile{f} = sprintf('%s,%d', sfile{f}, stats.ncross(f,d2,3));
    end
  end
  fprintf(')');
end
fprintf('\nnumbers of crossings for top and bottom borders and middle region%s:\n', inInv);
for f=1:nflies
  fprintf('fly %d: %d %d  %d', f, stats.ncross(f,1,1:3));
  if statsFile
    sfile{f} = sprintf('%s,%d', sfile{f}, stats.ncross(f,1,3));   % middle region only
  end
  if intervals
    reportXings(f, 2, 4);
  end
  if ~isempty(onIvs)
    reportXings(f, 5, 6);
  end
  fprintf('\n');
  if statsFile
    % note: line is now complete
    fprintf(YL.sf, [sfile{f}, '\n']);
  end
end

if numPeriods
  fprintf(['\nby period:\n  percent of time in regions top, middle, and bottom |\n', ...
    '  numbers of crossings for top and bottom borders and middle region:\n']);
  stats.periods = zeros(nflies*numPeriods, 4);   % fly&period, period and top|middle|bottom
  for f=1:nflies
    tM = frame2m(length(trx(f).x));
    fprintf('fly %d:  period length %.0fm (video: %.1fh)\n', f, tM/numPeriods, tM/60);
    for p=1:numPeriods
      nf = sum(stats.nframes(f,6+p,1:3));
      pcs = stats.nframes(f,6+p,1:3) .* (100/nf);
      fprintf('  period %d: %.1f %.1f %.1f | %d %d  %d\n', p, ...
        pcs, stats.ncross(f,6+p,1:3));
      stats.periods((f-1)*numPeriods+p, 1:4) = [p; squeeze(pcs)];
    end
  end
end

if eggfile
  [ecs, mddlEggs] = eggClassification();
end
evs = events();
[ris, rcs] = returnPoints();
if eggfile && ~skipBeforeEggLayingAnalysis
  ris = beforeEggLayingAnalysis();
  rcs = cellfun(@(x) zeros(1, length(x)), ris, 'UniformOutput', false);
end

plotTitle = '';
if exist('YL') && isfield(YL, 'plotTitle') && ~isempty(YL.plotTitle)
  plotTitle = YL.plotTitle;
end
  
if (showYPosPlots || ~isempty(plotTitle)) && numPeriods
  plotYPositionsOverTime();
end
if eggfile
  byEggAnalysis();
  middleXingDurations();
  plotEggLayingTimes();
  if false
    middleXingVsReturn();
  end
  if ~isempty(onIvs)
    uvOnOffAnalysis();
  end
  returnsAnalysis();
end

errorCheck();

assignin('base', 'stats', stats);

% - - -

%% template matching to determine border points etc.
function [match, bx, by, sapx, sapy] = matchTemplate
  fprintf('using template match to determine borders\n\n');
  if isempty(regexp(moviename, '\.jpg$'))
    error('template matching currently requires jpg');
  end
  imSz = size(imread(moviename));
  tmplts = {'Standard', 'Long720p'};
  ti = 1 + (imSz(1) == 720 && longChamber);
  res = python('match_template.py', moviename, tmplts{ti});
  rC = textscan(res, '%f %f %f %f %f', 'delimiter', ',');
  match = rC{3} >= 20;   % whether match worked
  if match
    if ti == 1
      f = rC{4};
      bx = ([15;381;  9;382;194]*f + rC{1})/2;   % coordinates from template
      by = ([55; 55;225;225;139]*f + rC{2})/2;
      sapx = {[11 11 17 29 43 146 158 169 174 174] ...   % order: TL, TR; BL, BR
        [218 218 223 234 246 349 363 375 381 381];
        [9 9 13 22 31 150 162 170 174 174] ...
        [218 218 222 230 242 361 370 379 383 383]};
      sapy = {[55 34 20 10 5 5 8 15 22 55] ...
        [55 22 15 8 5 5 10 20 34 55];
        [225 254 263 272 274 274 269 263 250 225] ...
        [225 250 263 269 274 274 272 263 254 225]};
      sapx = cellfun(@(v) (v*f+rC{1})/2, sapx', 'UniformOutput', false);
      sapy = cellfun(@(v) (v*f+rC{2})/2, sapy', 'UniformOutput', false);
    else
      [x1, y1, x2, y2] = deal(rC{1}, rC{2}, rC{4}, rC{5});
      bx = ([ 40;275; 41;273;158] + [x1;x1;x2;x2;x2]) * 240/720;
      by = ([143;143;816;816;476] + [y1;y1;y2;y2;y2]) * 320/1280;
      [sapx, sapy] = deal([], []);
    end
  end
end

% - - - shared by analysis - - -

%% varying background
% returns: onIvs: one "on" interval ([first frame on; last frame on]) per column
%  isOn: element for each frame, true iff "on"
function [onIvs, isOn] = onIntervals
  isOn = false(1, trxL);
  if isfield(trx, 'YL_on_changes')
    oc = trx(1).YL_on_changes;
    if oc(1,2) == 0
      oc(1,:) = [];
    end
    if oc(end,2) == 1
      oc(end+1,:) = [trxL+1, 0];
    end
    assert(mod(size(oc,1), 2) == 0);
    onIvs = reshape(oc(:,1), 2,[]);
    onIvs(2,:) = onIvs(2,:) - 1;

    for oi = onIvs
      if ~isempty(oi)
        isOn(oi(1):oi(2)) = true;
      end
    end
  else
    onIvs = [];
  end
end

%% read egg file
function eis = readEggFile
  ef = fopen([efpath, efname]);
  C = textscan(ef, '%u %u %u %u', 'delimiter', {',',':'}, 'commentStyle', '#');
  fclose(ef);

  eis = cell(1, nflies);   % egg indexes
  noColonFormat = max(C{3}) == 0 && max(C{4}) == 0;

  % check fly order and egg order
  pf = -1;   % previous fly
  for e=1:length(C{1})
    f = C{1}(e);
    if f ~= pf
      if f < pf
        error('fly number in egg file decreased');
      end
      eis{f} = [];
      [pf, pidx] = deal(f, 0);
    end
    if noColonFormat
      idx = uint32(hhmmss2s(C{2}(e)) * fps);
    else
      idx = (C{2}(e)*3600 + C{3}(e)*60 + C{4}(e)) * fps;
    end
    if idx < pidx
      error(sprintf('egg time in egg file decreased (fly %d, time %s)', ...
        f, f2hmsS(idx)));
    end
    eis{f} = [eis{f}, idx];
    pidx = idx;
  end
end

%% egg classification
function [ecs, mddlEggs] = eggClassification
  ecs = cell(1, nflies);   % classification: 1:1, 2:2a, 3:2b, 4:3
    % classification is based on time since prior egg
    % class 1: visit to opposite region
    % class 2: no visit to opposite region, class 2a: visit to middle region
    % class 3: egg in middle region
  mddlEggs = zeros(1, nflies);
  for f = 1:nflies
    [eisF, regs] = deal(eis{f}, trx(f).YL_reg);
    ecs{f} = ones(1, length(eisF));
    for e = 1:length(eisF)
      ei = eisF(e);
      er = regs(ei);
      if er == 2
        mddlEggs(f) = mddlEggs(f) + 1;
        ecs{f}(e) = 4;
      elseif e > 1
        if isempty(find(regs(pei:ei) ~= er, 1, 'first'))
          ecs{f}(e) = 3;
        elseif isempty(find(regs(pei:ei) == 4-er, 1, 'first'))
          ecs{f}(e) = 2;
        end
      end
      pei = ei;
    end
  end
end

%% returns events
% event types: region change (first frame in new region) or egg-laying
% event region: new region or 0 for egg-laying
% middle crossing: duration in frames (first frame after xing) or 0 for non-xing
function evs = events
  for f = 1:nflies
    regs = trx(f).YL_reg;
    if exist('eis', 'var')
      eisF = eis{f};
    else
      eisF = [];
    end
    pregs = [regs(1), regs(1:end-1)];
    chis = find(regs ~= pregs);
    evis = [eisF, chis];   % event indexes
    evrs = [zeros(1, length(eisF)), regs(chis)];   % event regions
    [evis, evOrder] = sort(evis);   % evOrder can be used for index mapping
    evrs = evrs(evOrder);
    [evs.idxs{f}, evs.regs{f}, evs.order{f}] = deal(evis, evrs, evOrder);

    % middle crossings; also handles fast crossings (w/out region 2 frames)
    mxs = zeros(1, length(evis));
    for i = 1:length(evis)
      er = evrs(i);
      if er == 1 || er == 3
        ei = evis(i);
        if ei > 1 && regs(ei-1) == 4-er   % fast xing
          mxs(i) = 1;
        elseif i > 1 && evis(i-1) > 1 && regs(evis(i-1)-1) == 4-er
          mxs(i) = ei - (evis(i-1)-1);
        end
      end
    end
    evs.mxings{f} = mxs;
  end
end

%% determines return points
% note: calculated independent of eggs (unlike the return points for class 1 and 2a
%  eggs calculated before)
% ris: return point indexes, rcs: whether "close" to border
function [ris, rcs] = returnPoints
  stats.returns = [];
  assert(yB(2) > yB(1));
  clDy = (yB(2)-yB(1)) * closeBorderDistanceFraction;
  for f = 1:nflies
    [regs, evis, evrs] = deal(trx(f).YL_reg, evs.idxs{f}, evs.regs{f});
    [risF, rcsF] = deal([], []);
    idxs = find(evrs == 2);
    for i = idxs
      fi = evis(i);
      if i == length(evrs) || fi < 2
        continue
      end
      pr = regs(fi-1);
      if pr == regs(evis(i+1))
        ys = trx(f).y(fi:evis(i+1)-1);
        if pr == 1
          [ymm, mmi] = max(ys);
          cl = ymm < yB(1) + clDy;
        else
          [ymm, mmi] = min(ys);
          cl = ymm > yB(2) - clDy;
        end
        mmi = mmi(1) + fi - 1;
        stats.returns(end+1, 1:5) = [f, f2hmsI(mmi), mmi, pr, cl];
        [risF(end+1), rcsF(end+1)] = deal(mmi, cl);
      end
    end
    [ris{f}, rcs{f}] = deal(risF, rcsF);
  end   
end

%% determine speed
% note: could be sped up
function spd = speed
  fprintf('calculating speed...\n');
  tic;
  df = floor(speedCalcS*fps/2);
  for f = 1:nflies
    [~, ds] = cart2pol(trx(f).x(2:end)-trx(f).x(1:end-1), ...
      trx(f).y(2:end)-trx(f).y(1:end-1));
    sp = zeros(1, length(trxL));
    for i = 1:trxL
      [mi, ma] = deal(max(1, i-df), min(trxL-1, i+df-1));
      sp(i) = sum(ds(mi:ma))/(ma-mi+1);
    end
    spd{f} = sp;
  end
  fprintf('  time: %.1fs\n\n', toc);
end

% - - - main analysis functions - - -

%% before egg-laying analysis
% returns indexes of "return points" for class 1 and 2a eggs
function ris = beforeEggLayingAnalysis
  fprintf(['\nby egg:\n  percent of time in regions top, middle, and bottom\n', ...
    '    in %d seconds before egg-laying |\n', ...
    '  time between entering egg-laying region and egg-laying\n', ...
    '  duration of last visit to opposite region |\n', ...
    '  time between "return point" and egg-laying\n', ...
    '  type of return point (10:opposite border, 11:middle)\n'], beforeEggS);
  stats.byEgg = [];
    % egg; fly, time, top|middle|bottom, before egg time, opposite region time
  for f = 1:nflies
    [eisF, ecsF] = deal(eis{f}, ecs{f});
    [evis, mxings] = deal(evs.idxs{f}, evs.mxings{f});
    [pli, risF] = deal(0, []);
    if isempty(eisF)
      continue
    end
    fprintf('fly %d:\n', f);
    for e = 1:length(eisF)
      if ecsF(e) == 4
        continue
      end
      li = eisF(e);
      fi = max(1, li - floor(beforeEggS * fps) + 1);
      fprintf('  %s: ', f2hmsS(li));
      stats.byEgg(end+1, 1:2) = [f, f2hmsI(li)];

      % percent of time
      regs = trx(f).YL_reg(fi:li);
      if fi <= pli
        pcs = NaN(1, 3);
        fprintf('overlap');
      else
        nf = double(li - fi + 1);
        pcs = [nnz(regs == 1), nnz(regs == 2), nnz(regs == 3)] .* (100/nf);
        fprintf('%.1f %.1f %.1f', pcs);
      end

      % time between entering egg-laying region and egg-laying, etc.
      regE = regs(end);
      regO = 4 - regE;
      regsA = trx(f).YL_reg(1:li);
      [eS, rS, rT] = deal(NaN, NaN, NaN);
      fiE = find(regsA ~= regE, 1, 'last');
      if ~isempty(fiE)
        eS = frame2s(li - fiE);

        idx = find(evis == fiE+1, 1);
        assert(~isempty(idx), 'event must exist');
        if ecsF(e) == 1 || ecsF(e) == 2
          if mxings(idx)
            assert(ecsF(e) == 1, 'middle crossing only for class 1');
            [rS, rT] = deal(frame2s(mxings(idx)-1) + eS, 10);
          elseif idx > 1
            ys = trx(f).y(evis(idx-1):fiE+1);
            if ys(end-1) > ys(end)
              yM = max(ys);
            else
              yM = min(ys);
            end
            idx1 = find(ys == yM, 1, 'last');
            assert(~isempty(idx1), 'max (or min) must exist');
            [rS, rT] = deal(frame2s(length(ys)-idx1-1) + eS, 11);
            risF(end+1) = idx1 + evis(idx-1)-1;
          end
        end
      end
      oS = NaN;
      liO = find(regsA == regO, 1, 'last');
      if ~isempty(liO)
        fiO = find(trx(f).YL_reg(1:liO) ~= regO, 1, 'last');
        if ~isempty(fiO)
          oS = frame2s(liO - fiO);
        end
      end
      fprintf(' | %.1fs %.1fs | %.1fs %d\n', eS, oS, rS, rT);

      stats.byEgg(end, 3:9) = [pcs, eS, oS, rS, rT];
      pli = li;
    end   % for each egg
    ris{f} = risF;
  end

  % durations of visits
  if intervals
    fprintf(['\ndurations of visits to top and bottom regions during intervals:\n', ...
      '  columns in stats.visits: fly, region (1:top, 3:bottom),\n', ...
      '    time region entered (01:02:59 as 10259), duration in seconds\n']);
    c1 = 0;
    for f=1:nflies
      fprintf('fly %d\n', f);
      fi = ivsF(f,1);
      li = ivsF(f,2);
      for reg=[1,3]
        fprintf('region %s:\n', REGIONS{reg});
        pr = reg;   % note: skips already ongoing visit
        fiR = 0;
        c = 0;
        for i=fi:li
          r = trx(f).YL_reg(i); 
          if r ~= pr
            if r == reg   % visit start
              fiR = i;
            elseif pr == reg && fiR > 0   % visit end
              dS = frame2s(i - fiR);
              if c < showVisits
                fprintf('  %s: %.1fs\n', f2hmsS(fiR), dS);
              elseif c == showVisits
                fprintf('  ... see stats.visits for more\n');
              end
              c = c + 1;
              c1 = c1 + 1;
              stats.visits(c1, 1:4) = [f, reg, f2hmsI(fiR), dS];
            end
            pr = r;
          end
        end
      end
    end
  end

end   % beforeEggLayingAnalysis

%% plot y positions over time
function plotYPositionsOverTime

  [dkGr, ele] = deal([0 .7 0], sucrosePaper || uvPaper);
  colors = choice(ele, {'k', 'k', 'k', 'k'}, {'r', dkGr, dkGr, [.75 .6 0]});   % by egg class
  colorsTr = {'r', choice(uvPaper, [.6 .6 .8], 'b')};   % trajectory: high speed, low (default)
  colorsRp = {[.4 .4 .4], [.8 .2 .2]};   % return points: regular, close
  colorsRpUv = {'k', [.6 .19 1]};   % to dark, to UV
  classes = choice(ele, {'ELE', 'ELE', 'ELE', 'ELE'}, {'1', '2a', '2b', '3'});
  timeMin = [0:trxL]/fps/60;   % double

  for f=1:nflies
    [ys, ymm] = deal(trx(f).y, trx(f).YL_y_min_max);
    if speedCalc
      lwSp = spd{f} < speedTh;
    end
    for p = 1:numPeriods
      [fi, li] = p2fl(p, trxL);
      pltTtl = sprintf('Fly %d, Period %d', f, p);
      figure('Name', pltTtl);
      title(prependPlotTitle(pltTtl));
      set(gca, 'YDir', 'rev');
      hold on;

      % overlapping "on" intervals
      if isempty(onIvs)
        ois = [];
      else
        ovlp = (onIvs(1,:)<=li) .* (onIvs(2,:)>=fi);
        ois = reshape(onIvs(logical(ovlp([1 1], :))), 2,[]);
      end
      for oi = ois
        if ~isempty(oi)
          x12 = timeMin([max(oi(1),fi), min(oi(2),li)]);
          patch([x12(1), x12(2), x12(2), x12(1)], [yB(1), yB(1), yB(2), yB(2)], ...
            [.92 .90 1], 'EdgeColor', 'none');
        end
      end
      plotBorders(timeMin([fi, li]), yB, ymm);
      for oi = ois
        if ~isempty(oi)
          if oi(1) >= fi && oi(1) > 1
            plot(timeMin([oi(1), oi(1)]), ymm, 'Color', [.6 .5 .9]);
          end
          if oi(2) <= li && oi(2) < trxL
            plot(timeMin([oi(2), oi(2)]), ymm, 'Color', [.6 .5 .9]);
          end
        end
      end

      % trajectory
      if speedCalc
        ci = fi;
        while ci <= li
          [ls, ni] = deal(lwSp(ci), li+1);
          if ci < li
            nir = find(lwSp(ci+1:li) ~= ls, 1, 'first');
            if ~isempty(nir)
              ni = ci+nir;
            end
          end
          plot(timeMin(ci:ni-1), ys(ci:ni-1), 'Color', colorsTr{ls+1});
          ci = ni;
        end
      else
        plot(timeMin(fi:li), ys(fi:li), 'Color', colorsTr{2});
      end
      if eggfile
        eisF = eis{f};
        for e = 1:length(eisF)
          ei = eisF(e);
          if fi <= ei && ei <= li
            [tm, y] = deal(timeMin(ei), ys(ei));
            ci = ecs{f}(e);
            plot([tm, tm], [y-10, y+10], 'Color', colors{ci}, 'linewidth', .5);
            top = trx(f).y(ei) < mean(yB);
            dx = timeMin(end)/numPeriods/choice(ele, 250, 500);
            text(tm+dx, y+10-20*top, classes{ci}, 'Color', colors{ci}, ...
              'FontWeight', 'bold', 'FontSize', choice(ele, 8, 'default'));
          end
        end
      end
      if showReturnPoints && exist('ris', 'var') && f <= length(ris)
        [risF, rcsF] = deal(ris{f}, rcs{f});
        idxs = find((fi<=risF) .* (risF<=li));
        for i = idxs
          fr = risF(i);
          yr = trx(f).y(fr);
          if uvPaper
            toUv = (fr > 1 && trx(f).y(fr-1) < yr || trx(f).y(fr+1) < yr) == uvOnTop;
          end
          plot(timeMin(fr), yr, choice(uvPaper && toUv, 's', 'o'), ...
            'Color', choice(uvPaper, colorsRpUv{toUv+1}, colorsRp{rcsF(i)+1}), ...
            'MarkerSize', 9, 'LineWidth', choice(uvPaper, 1.5, 'default'));
        end
      end
      hold off;
      xlabel('time (min)');
    end
  end
end

%% by egg before border crossing analysis
% notes:
% * unlike in by egg before egg-laying analysis, trajectories here end in crossing
% * only for non-cluster (class 1) eggs
% * if egg-laying in beforeXingStatsS for egg or control, exclude from stats and plot
function byEggAnalysis

  beforeXingPlotF = floor(beforeXingPlotS * fps);
  timeSec = [-beforeXingPlotF:0] / fps;
  beforeXingStatsF = floor(beforeXingStatsS * fps);
  kFromN = @(k,n) sprintf('%d chosen from %d', k, n);

  stats.beforeXing = [];

  fprintf(['\nby egg in %ds before border crossing:\n', ...
    '  number of visits to top and bottom |\n', ...
    '  average duration of visits to top and bottom\n', ...
    'columns in stats.beforeXing: fly, region (1:top/3:bottom), 1:egg/0:control\n', ...
    '  time, number visits top|bottom, avg. visit duration top|bottom\n'], ...
    beforeXingStatsS);
  for f = 1:nflies
    [eisF, ecsF] = deal(eis{f}, ecs{f});
    if isempty(eisF)
      continue
    end
    fprintf('fly %d:\n', f);
    exclEggs = {};

    regs = trx(f).YL_reg;
    [evis, evrs, evOrder] = deal(evs.idxs{f}, evs.regs{f}, evs.order{f});

    % mark possible controls
    %  limit to top or bottom visits between first and last egg
    [fi, li] = deal(eisF(1), eisF(end));
    ctrls = zeros(1, length(evis));   % possible controls will have 1 or 3
    numev = length(evis);
    for i = 1:numev
      evi = evis(i);
      if fi < evi && evi < li
        evr = evrs(i);
        if evr == 1 || evr == 3
          if (i == numev || evrs(i+1) ~= 0) && ~eggLayingBeforeXing(i)
            ctrls(i) = evr;
          end
        end
      end
    end

    % stats and plot
    for reg = [1,3]
      pltTtl = sprintf('%ds before %s border crossings -- Fly %d', ...
        beforeXingPlotS, REGIONS{reg}, f);
      figure('Name', pltTtl);
      hax = createsubplots(2, 1, 0.05);

      % eggs
      fprintf('eggs %s\n', REGIONS{reg});
      axes(hax(1));
      set(gca, 'YDir', 'rev');
      hold on;
      plotBorders(timeSec([1,end]), yB, trx(f).YL_y_min_max);
      idxs = find(evrs == 0);
      for i = idxs
        if ecsF(evOrder(i)) > 1 || i == 1
          continue
        end
        li = evis(i-1);   % xing
        if regs(li) == reg && li >= beforeXingStatsF
          if eggLayingBeforeXing(i-1)
            exclEggs = [exclEggs, f2hmsS(evis(i))];
          else
            topBottomVisitsStats(li, evis(i), 1);
            plotYPos(li, 'r');
          end
        end
      end
      hold off;
      title(prependPlotTitle(pltTtl));

      % controls
      axes(hax(2));
      set(gca, 'YDir', 'rev');
      hold on;
      plotBorders(timeSec([1,end]), yB, trx(f).YL_y_min_max);
      idxs = find(ctrls == reg);
      [smpl, n, k] = randomSample(idxs, numControlsForStats);
      fprintf('controls %s (%s)\n', REGIONS{reg}, kFromN(k, n));
      for i = smpl
        li = evis(idxs(i));
        topBottomVisitsStats(li, li, 0);
      end      
      [smpl, n, k] = randomSample(idxs, numControlsForPlot);
      for i = smpl
        plotYPos(evis(idxs(i)), 'b');
      end
      hold off;
      title(sprintf('controls (no egg-laying after crossing, %s)', kFromN(k, n)));
    end

    if ~isempty(exclEggs)
      fprintf('excluded eggs (other egg in %ds before crossing):\n  %s\n', ...
        beforeXingStatsS, strjoin(exclEggs, ', '));
    end
  end

  function topBottomVisitsStats(li, timeF, isEgg)
    if li > 1
      li = li - 1;   % exclude "crossing frame"
      fi_ = max(1, li - beforeXingStatsF + 1);
      regs1 = regs(fi_:li);
      nfs = [nnz(regs1 == 1), nnz(regs1 == 3)];
      pregs1 = [-1, regs1(1:end-1)];   % -1 includes fi
      evrs1 = regs1(regs1 ~= pregs1);
      nvs = [nnz(evrs1 == 1), nnz(evrs1 == 3)];
      ads = nfs ./ nvs / fps;
      fprintf('  %s: %d %d | %.1fs %.1fs\n', f2hmsS(timeF), nvs, ads);
      stats.beforeXing = [stats.beforeXing; ...
        [f, reg, isEgg, f2hmsI(timeF), nvs, ads]];
    end
  end

  function plotYPos(li, col)
    fi_ = li - beforeXingPlotF;
    if fi_ > 0
      plot(timeSec, trx(f).y(fi_:li), col);
    end
  end

  function tf = eggLayingBeforeXing(i)
    pei_ = find(evrs(1:i-1) == 0, 1, 'last');
    if isempty(pei_)
      tf = false;
    else
      tf = evis(i) - evis(pei_) < beforeXingStatsF;
    end
  end

end   % byEggAnalysis

%% durations of middle crossings before class 1 eggs
function middleXingDurations
  fprintf(['\ntwo middle crossings (mxings, in temporal order) before class 1 eggs:\n', ...
    '  duration | total angle change\n', ...
    'columns in stats.mXing: fly, region (1:top/3:bottom), time,\n', ...
    '  mxing durations, total angle change during mxings\n']);
  stats.mXing = [];
  if plotMiddleXings
    [nsubp, ncols, mrkrs, cols, align] = deal(18, 6, {'^', 'o', 'v'}, {'b', [0 .6 0]}, {'left', 'right'});
  end
  for f = 1:nflies
    [eisF, ecsF, mxings] = deal(eis{f}, ecs{f}, evs.mxings{f});
    if isempty(eisF)
      continue
    end
    fprintf('fly %d:\n', f);
    regs = trx(f).YL_reg;
    [evis, evrs, evOrder] = deal(evs.idxs{f}, evs.regs{f}, evs.order{f});
    if plotMiddleXings
      saps = cellfun(@(x) [x, x(1)], {sapx{f,1}, sapy{f,1}, sapx{f,2}, sapy{f,2}}, 'UniformOutput', false);
      xmean = mean([max(saps{1}), min(saps{1})]);
    end

    [nex, nin] = deal(0, 0);
    idxs = find(evrs == 0);
    for i = idxs   % for each egg
      if ecsF(evOrder(i)) > 1
        continue
      end
      ei = evis(i);
      mxIdxs = find(mxings(1:i), 2, 'last');
      if length(mxIdxs) == 2 && ...
         mxIdxs(2) == i-1 && ...                         % mxing right before egg
         frame2s(ei-evis(i-1)) <= maxPreELDelay && ...   % limit pre egg-laying delay
         isempty(find(evrs(mxIdxs(1)-1:i-1) == 0, 1))    % no other egg
        er = regs(ei);
        mxsS = frame2s(mxings(mxIdxs));
        for x = 1:2
          li = evis(mxIdxs(x));
          fi = li - mxings(mxIdxs(x));
          tdthe(x) = sum(abs(angleDiff(trx(f).theta(fi+1:li), trx(f).theta(fi:li-1)))) * 180/pi;
        end
        fprintf('  %s: %.1fs %.1fs | %.0f° %.0f°\n', f2hmsS(ei), mxsS, tdthe);
        stats.mXing(end+1, :) = [f, er, f2hmsI(ei), mxsS, tdthe];

        if plotMiddleXings
          idx1 = 1 + mod(nin, nsubp);
          if idx1 == 1
            figure('Name', sprintf('Two middle crossings before egg -- Fly %d', f));
            hax = reshape(reshape(createsubplots(3, ncols, 0.05), [3, ncols])', [1, nsubp]);
          end
          axes(hax(idx1));
          set(gca, 'YDir', 'reverse', 'DataAspectRatio', [1 1 1]);
          ttl = sprintf('%s', f2hmsS(ei));
          if idx1 == 1
            ttl = prependPlotTitle([sprintf('Fly %d -- ', f), ttl], true, true);
          end
          title(sprintf(ttl));
          hold on;
          arrayfun(@(i) plot(saps{i}, saps{i+1}, 'Color', [.5 .5 .5]), [1,3]);
          for x = 1:2
            li = evis(mxIdxs(x));
            fi = li - mxings(mxIdxs(x));
            plot(trx(f).x(fi:li), trx(f).y(fi:li), 'Color', cols{x});
            [xl, yl] = deal(trx(f).x(li), trx(f).y(li));
            if x == 2
              plot(xl, yl, mrkrs{er}, 'Color', cols{x}, 'MarkerSize', 8);
            end
            text(xl, yl+10-20*(regs(li)==1), sprintf('%.1fs, %.0f°', mxsS(x), tdthe(x)), ...
              'Color', cols{x}, 'HorizontalAlignment', align{1 + (xl>xmean)});
          end
          hold off;
          axis tight;
          lims = axis;
          [bx, by] = deal(0.04*(lims(2)-lims(1)), 0.02*(lims(4)-lims(3)));
          axis(lims + [-bx, bx, -by, by]);
        end
        nin = nin + 1;
      else
        nex = nex + 1;
      end
    end   % for each egg
    if nex
      fprintf('  number of class 1 eggs skipped: %d\n', nex);
    end
    if plotMiddleXings
      arrayfun(@(i) delete(hax(i)), idx1+1:nsubp);
    end
  end
end

%% egg-laying times plots
function plotEggLayingTimes
  maxX = frame2m(trxL);
  xTickD = choice(xTickDeltaM > 0, xTickDeltaM, round(maxX/8));
  colors = choice(sucrosePaper, {'k', '', 'k'}, {'b', '', 'r'});
  figure('Name', 'Time between egg-layings');
  hax1 = createsubplots(2, 1, 0.12);
  figure('Name', 'Time between crossings and egg-layings');
  hax2 = createsubplots(2, 1, 0.12);
  figure('Name', 'Egg-laying times');
  hax3 = createsubplots(2, 1, 0.1);
  stats.timeBetweenEggs = [];
  for f = 1:nflies
    [eisF, ecsF] = deal(eis{f}, ecs{f});
    [evis, evrs] = deal(evs.idxs{f}, evs.regs{f});
    regs = trx(f).YL_reg;
    pltTtl = prependPlotTitle(sprintf('Fly %d', f), f == 1);

    % time between eggs histogram
    axes(hax1(f));
    if length(eisF) > 1
      dfs = eisF(2:end) - eisF(1:end-1);
      dms = frame2m(dfs);
      hist1(dms, 0.5:59.5, f == 1);
      stats.timeBetweenEggs = [stats.timeBetweenEggs; [ones(1,length(dfs))*f; frame2s(dfs)]'];
    end
    title(pltTtl);
    xlabel('time between egg-layings (min)');

    % time between crossings and egg-layings
    axes(hax2(f));
    tms = [];
    idxs = find(evrs == 0);
    for i = idxs
      if ecsF(evs.order{f}(i)) == 1 && i > 1
        assert(evrs(i-1) ~= 0, 'previous event should not be egg');
        tms(end+1) = frame2s(evis(i)-evis(i-1));
      end
    end
    hist1(tms, 1:2:179, f == 1);
    title(pltTtl);
    xlabel('time between crossings and egg-layings for class 1 (sec)');
    ylim2{f} = ylim;

    % eggs on time axis
    axes(hax3(f));
    hold on;
    for ei = eisF
      x = frame2m(ei);
      plot([x x], [0.15, 0], colors{regs(ei)}, 'LineWidth', choice(sucrosePaper, 2, 'default'));
    end
    hold off;
    title(pltTtl);
    axis([0, maxX, 0, 1]);
    if sucrosePaper
      set(gca, 'FontSize', 12);
    end
    xlabel('egg-laying time (min)');
    set(gca, 'YTick', [], 'YColor', 'w', 'XTick', 0:xTickD:maxX);
    if f == 1 && ~sucrosePaper
      text(maxX/10, .7, '{\color{blue}top}, {\color{red}bottom}');
    end

  end

  % adjust y axis limits
  fg = ylim2{1}(2) > ylim2{2}(2);
  ylim(hax2(fg+1), ylim2{2-fg});

  function hist1(data, xcenters, addLBICA)
    hist(min(data, xcenters(end)), xcenters);
    h = findobj(gca, 'Type', 'patch');
    set(h, 'FaceColor', 'w', 'LineWidth', 1.2);
    if addLBICA
      yl = ylim;
      text(xcenters(end)/2, yl(2)*0.65, 'last bin is catch-all');
    end
    tl = 0.4 * 1/length(xcenters);
    set(gca, 'TickLength', [tl tl]);
    ylabel('number of occurrences');
  end
end

% UV on off analysis
function uvOnOffAnalysis()
  fprintf(['\neggs laid during "UV off" times:\n', ...
    '  region (1:top/3:bottom), time since last "on" frame\n', ...
    'columns in stats.uvOnOff: fly, time, region, time since last "on" frame\n']);
  stats.uvOnOff = [];
  for f = 1:nflies
    [eisF, regs] = deal(eis{f}, trx(f).YL_reg);
    if isempty(eisF)
      continue
    end
    fprintf('fly %d:\n', f);
    ls = length(stats.uvOnOff);
    for e = 1:length(eisF)
      ei = eisF(e);
      if isOn(ei)
        continue
      end
      [er, df] = deal(regs(ei), double(ei) - onIvs(2,:));
      sslo = frame2s(min(df(df>0)));
      if isempty(sslo)
        sslo = NaN;
      end
      fprintf('  %s: %d, %.1fs\n', f2hmsS(ei), er, sslo);
      stats.uvOnOff(end+1, :) = [f, f2hmsI(ei), er, sslo];
    end
    if ls == length(stats.uvOnOff)
      fprintf('  no egg during "UV off"\n')
    end
  end
end

% returns before eggs analysis
% note: uses stats.returns
function returnsAnalysis
  fprintf(['\nanalysis of %ds before eggs:\n', ...
    '  number of returns to top and bottom (non-close to border) |\n', ...
    '  percent of time in regions top, middle, and bottom\n'], returnsBeforeEggS);
  stats.returnsByEgg = [];
  [df, medf] = deal(round(returnsBeforeEggS*fps), round(minEggDistanceS*fps));
  for f = 1:nflies
    [eisF, regs] = deal(eis{f}, trx(f).YL_reg);
    if isempty(eisF)
      continue
    end
    [inclF, lei, exL, isEx] = deal(zeros(1, trxL), 0, {}, zeros(1, length(eisF)));
    for e = 1:length(eisF)
      ei = eisF(e);
      if lei == 0 || ei-lei >= medf
        inclF(max(1,ei-df):ei) = e;
      else
        exL = [exL, f2hmsS(ei)];
        isEx(e) = 1;
      end
      lei = ei;
    end
    [rTo, rByE] = deal(zeros(2, 3), zeros(2, 3, length(eisF)));
    for rw = stats.returns'
      assert(length(rw) == 5 && (rw(4) == 1 || rw(4) == 3));
      e = inclF(rw(3));
      if rw(1) == f && e
        [r, cl, aNc] = deal(rw(4), rw(5), [1]);
        if ~cl   % non-close
          aNc = [1, 2];
        end
        rTo(aNc, r) = rTo(aNc, r) + 1;
        rByE(aNc, r, e) = rByE(aNc, r, e) + 1;
      end
    end
    tmb = nfr(regs(logical(inclF)));
    fprintf('fly %d: %d %d (%d %d) | %.1f %.1f %.1f\n', ...
      f, rTo(1, [1,3]), rTo(2, [1,3]), tmb .* (100/sum(tmb)));
    for e = 1:length(eisF)
      ei = eisF(e);
      rs = [rByE(1, [1,3], e), rByE(2, [1,3], e)];
      if isEx(e)
        rs = NaN(1, 4);
      else
        fprintf('  %s: %d %d (%d %d)\n', f2hmsS(ei), rs);
      end
      stats.returnsByEgg(end+1, 1:6) = [f, f2hmsI(ei), rs];
    end
    if ~isempty(exL)
      fprintf('  excluded eggs: %s\n', strjoin(exL, ', '));
    end
  end
end

% - - -

%% error checking
function errorCheck()
  if sum(stats.nsep) > 0
    fprintf('\n*** separator crossings (Ctrax tracking issue): ***\n');
    for f=1:nflies
      ns = stats.nsep(f);
      sepF = '';
      if ns > 0
        sepF = sprintf('  (%d', sepFrames{f}(1));
        for s=2:min(ns,10)
          sepF = sprintf('%s, %d', sepF, sepFrames{f}(s));
        end
        if ns > 10
          sepF = sprintf('%s, ...', sepF);
        end
        sepF = sprintf('%s)', sepF);
      end
      fprintf('fly %d: %d%s\n', f, ns, sepF);
    end
  else
    if sep > 0
      fprintf('\nno separator crossings\n');
    else
      fprintf('\nwarning: check for separator crossings not performed\n');
    end
  end

  if flipY
    if matname
      if isempty(regexp(matname, 'AD\.mat$'))
        fprintf('\n*** error: vertical flipping on but M-JPEG seems not to be used ***\n');
      end
    else
      fprintf('\nwarning: vertical flipping on; make sure M-JPEG was used\n');
    end
  end

  if exist('mddlEggs', 'var') && sum(mddlEggs)
    mes = {};
    for f = 1:nflies
      mes = [mes, sprintf('fly %d: %d', f, mddlEggs(f))];
    end
    fprintf('\neggs in middle region: %s\n', strjoin(mes, ', '));
  end

  if ~isempty(warnings)
    fprintf('\nother warnings:\n');
    fprintf(strjoin(warnings, '\n'));   % using %s made \n not work
    fprintf('\n');
  end
end

%% "on substrate" classification
function onSubstrateClassification(f)
  doPlot = false;
  if f == 1   % plot only for fly 1
    avi = regexprep(matname, '\.mat$', '.avi');
    doPlot = exist(avi, 'file');
    if doPlot
      readframe = getReadframe(avi);
      pfig = gcf;
      figure('Name', '"on substrate" classification');
      hax = reshape(createsubplots(4, 6, 0.02), 4, 6);
      ascDesc = {'ascend', 'descend'};
    end
  end

  idxs = find(inSap{f} > 0);
  [a, b] = deal(trx(f).a(idxs), trx(f).b(idxs));
  ab = a ./ b;
  [bDl, abDl] = deal(b - bMax, ab-abMin);
  onSubsF = (bDl < 0) .* (abDl > 0);
  onSubs{f} = zeros(1, trxL);
  onSubs{f}(idxs) = onSubsF;
  
  if doPlot
    plotFrames(onSubsF, b, true, 1, 'b', 'ok', 'y');
    plotFrames(bDl > 0, b, false, 2, 'b', 'too big', 'r');
    plotFrames(onSubsF, ab, false, 3, 'a/b', 'ok', 'y');
    plotFrames(abDl < 0, ab, true, 4, 'a/b', 'too round', 'r');

    figure(pfig);
  end

  function plotFrames(subset, vals, showMax, row, var, txt, col)
    subset = logical(subset);
    [idxs1, vals1] = deal(idxs(subset), vals(subset));
    [vals1, so] = sort(vals1, ascDesc{showMax + 1});
    idxs1 = idxs1(so);
    for i = 1:6
      axes(hax(row, i));
      set(gca, 'YDir', 'rev');
      fi = idxs1(i);
      im = readframe(fi);
      hold on;
      imagesc(im);
      [x, y] = getXy(f, fi);
      plotEllipse(f, fi, col, 40);
      if i == 1
        text(x + 60, y, txt, 'Color', col);
      elseif i == 2
        text(x + 60, y, sprintf('%s=%.1f', var, vals1(i)), 'Color', col);
      end
      hold off;
      axis image;
      axis off;
    end
  end
end

%% save substrate-related classification
function saveSubstrateClassification
  mn2 = regexprep(matname, '\.mat$', ' subs.mat');
  if strcmp(mn2, matname)
    error('second MAT-file name conflict');
  end
  regs = arrayfun(@(e) e.YL_reg, trx, 'UniformOutput', false);
  % reverse flySortOrder
  [inSap(flySortOrder), onSubs(flySortOrder), regs(flySortOrder)] = deal(inSap, onSubs, regs);
  save(mn2, 'inSap', 'onSubs', 'regs', 'abMin', 'bMax', 'bx', 'by');
end

%% plot jumps
function plotFlyJumps
  avi = regexprep(matname, '\.mat$', '.avi');
  aviExists = exist(avi, 'file');
  assert(nflies == 2);
  pfig = gcf;
  colors = {'g', 'y', 'r', 'w'};   % regular, suspicious, more suspicious, fixed
  if aviExists
    readframe = getReadframe(avi);
  end
  [nsubp, first, maxFigures, nf] = deal(4*3, true, 15, 4);
  sL = round(fps*30);   % stop length

  for f = 1:nflies
    % jump frame indexes
    dx = trx(f).x(2:end) - trx(f).x(1:end-1);
    dy = trx(f).y(2:end) - trx(f).y(1:end-1);
    [the, dst] = cart2pol(dx, dy);
    jis = find(dst > 25);

    [fig, sp, i, pji] = deal(1, 1, 0, -99);

    while true   % for each jump
      i = i + 1;

      % do not show overlapping jumps
      % note: changed "overlapping" to "consecutive;" code below could be simplified
      while true
        if i > length(jis)
          break
        end
        ji = jis(i);   % pre-jump frame
        if ji - pji > 1
          break
        end
        i = i + 1;
      end
      if i > length(jis)
        break
      end
      if ji < 2 || ji+nf-2 > trxL
        continue
      end
      if false && ji < 3600*fps   % HACK to skip first hour
        continue
      end
      pji = ji;

      % check whether jump suspicious
      % note: uses several hardcoded parameters to determine suspiciousness
      [susp, isOnChange, fix, th] = deal(0, 0, 0, the(ji));
      % next jump in opposite direction from new position
      if i < length(jis)
        ji2 = jis(i+1);
        th2 = the(ji2);
        dth = abs(angleDiff(th2, th));
        susp = dth*180/pi > 135 && distance(f, ji+1, ji2) < 5;

        % possibly fix
        isOnChange = ~ all(isOn(ji-1:ji+2) == isOn(ji));
        fix = autoFix && susp && isOnChange && ji2 - ji == 1;
        if fix
          [trx(f).x(ji+1:ji2), trx(f).y(ji+1:ji2), ...
             trx(f).a(ji+1:ji2), trx(f).b(ji+1:ji2), trx(f).theta(ji+1:ji2)] = ...
             interpolateXyabt(f, ji, ji2+1);
          susp = 3;
        end
      end
      % no movement before or after jump
      if ~susp
        susp = 2* (ji >= sL && maxDistance(f, ji, ji-sL+1, ji) < 1 || ...
          ji+sL <= trxL && maxDistance(f, ji+1, ji+1, ji+sL) < 1);
      end
      if onlySuspicious && ~susp || ~showFixed && fix
        continue
      end

      % plot
      if sp == 1   % first subplot?
        if fig > maxFigures
          break
        end
        figure('Name', sprintf('Jumps for fly %d (#%d)', f, fig));
        hax = reshape(reshape(createsubplots(4, 3, 0.03), [4, 3])', [1, nsubp]);
        fig = fig + 1;
      end
      axes(hax(sp));
      set(gca, 'YDir', 'rev');
      im = [];
      for j = 0:nf-1
        if aviExists
          im1 = convertImage(readframe(ji+j));   % readframe seems off by 1
        else
          im1 = imBT;
        end
        if first
          [w, h, first] = deal(round(min(sep, size(im1, 2)-sep+1)), size(im1, 1), false);
        end
        x1 = round(sep - (w-1)*(f==1));
        im = [im, imcrop(im1, [x1, 1, w, h])];
      end
      hold on;
      imagesc(im);
      for j = 0:nf-1
        [i1, dx] = deal(ji+j-1, j*w-(x1-1)+1);
        plotEllipse(f, i1, colors{susp+1}, dx);
        plot(trx(f).x(i1-1:i1)+dx, trx(f).y(i1-1:i1), colors{susp+1});
      end
      if ~aviExists && sp == 1
        text(5, 5, 'static image', 'Color', 'w', 'VerticalAlignment', 'top');
      end
      hold off;
      axis image;
      axis off;
      title(sprintf('f=%d (%s) d=%.0f', ji+1, f2hmsS(ji+1), dst(ji)));

      sp = sp + 1;
      if sp > nsubp   % done with figure
        sp = 1;
      end
    end   % for each jump
    if sp > 1
      arrayfun(@(i) delete(hax(i)), sp:nsubp);
    end
  end
  figure(pfig);
end

%% the following can be calculated from the "numbers of crossings" info
function middleXingVsReturn
  fprintf('\n*** to check ***\n');
  for f = 1:nflies
    [evis, evrs, regs] = deal(evs.idxs{f}, evs.regs{f}, trx(f).YL_reg);
    idxs = find(evrs == 2);
    ns = [0 0];
    for i = idxs
      if evis(i) > 1 && regs(evis(i)-1) == 3 && i < length(evrs)
        nidx = 1 + (evrs(i+1) == 3);   % 1: bottom to top, 2: return to bottom
        ns(nidx) = ns(nidx) + 1;
      end
    end
    fprintf('fly %d: bottom to top: %d, return to bottom: %d\n', f, ns);
  end
end

% - - - nested utility functions - - -

% returns time of given frame as fraction of day
function d = frame2day(f)
  d = double(f)/(24*3600*fps);
end
% returns time of given frame in seconds (as double)
function s = frame2s(f)
  s = double(f)/fps;
end
% returns time of given frame in minutes (as double)
function m = frame2m(f)
  m = double(f)/(60*fps);
end
% converts the given frame to hhmmss integer (e.g., 10001 for 01:00:01)
function i = f2hmsI(f)
  i = str2num(datestr(frame2day(f), 'HHMMSS'));
end
% converts the given frame to hhmmss string (e.g., "01:00:01")
function s = f2hmsS(f)
  s = datestr(frame2day(f), 'HH:MM:SS');
end

% returns the first and last frame for the given period
function [f, l] = p2fl(p, trxL)
  pL = trxL/numPeriods;
  [f, l] = deal(1 + round((p-1)*pL), min(round(p*pL), trxL));
end

% prepend plotTitle
function nt = prependPlotTitle(t, cond, newline)
  if ~isempty(plotTitle) && (~exist('cond', 'var') || cond)
    seps = {' -- ', '\n'};
    nt = strjoin({plotTitle, t}, seps{1 + (exist('newline', 'var') && newline)});
  else
    nt = t;
  end
end

% returns the x and y coordinates of the given fly at the given frame
function [x, y] = getXy(f, fi)
  [x, y] = deal(trx(f).x(fi), trx(f).y(fi));
end
% returns a, b, and theta of the given fly at the given frame
function [a, b, th] = getAbt(f, fi)
  [a, b, th] = deal(trx(f).a(fi), trx(f).b(fi), trx(f).theta(fi));
end
% returns the distance for the given fly for the two given frames
function d = distance(f, f1, f2)
  [~, d] = cart2pol(trx(f).x(f2)-trx(f).x(f1), trx(f).y(f2)-trx(f).y(f1));
end
% returns the maximum distance for the given fly and frame and frame range
function maxD = maxDistance(f, fi, f1, f2)
  [x, y] = getXy(f, fi);
  [~, ds] = cart2pol(trx(f).x(f1:f2)-x, trx(f).y(f1:f2)-y);
  maxD = max(ds);
end
% returns trajectory interpolation for the given two frames
function [x, y, a, b, th] = interpolateXyabt(f, f1, f2)
  n = f2 - f1;
  assert(n > 1, 'at least one frame in-between');
  [x1, y1] = getXy(f, f1);
  [x2, y2] = getXy(f, f2);
  [x, y] = deal(x1:(x2-x1)/n:x2, y1:(y2-y1)/n:y2);
  [x, y] = deal(x(2:n), y(2:n));

  [a1, b1, th1] = getAbt(f, f1);
  [a2, b2, th2] = getAbt(f, f2);
  dth = angleDiff(th2, th1);
  [a, b, th] = deal(a1:(a2-a1)/n:a2, b1:(b2-b1)/n:b2, th1:dth/n:th1+dth);
  [a, b, th] = deal(a(2:n), b(2:n), th(2:n));
end

% plots ellipse for the given fly at the given frame
function plotEllipse(f, fi, col, dx)
  if ~exist('dx', 'var')
    dx = 0;
  end
  [x, y] = getXy(f, fi);
  ellipsedraw(2*trx(f).a(fi), 2*trx(f).b(fi), x + dx, y, trx(f).theta(fi), col);
end

% converts image
% note: mirrors Avidemux video conversion
function im = convertImage(im)
  if size(im, 1) == 480
    im = imresize(im, 0.5);
  elseif size(im, 1) == 720
    im = imresize(im, 'Scale', [240/720, 320/1280]);
  end
  if longChamber
    im = imrotate(im, -90);
  end
end

% plot borders
function plotBorders(x, yB, ymm)
  [x1, x2, dfltCol, uvCol] = deal(x(1), x(2), [.93 .93 .93], [.9 .87 1]);
  x1p = x1 + (x2-x1)/1000;
  if uvPaper
    cols = choice(uvOnTop, {uvCol, dfltCol}, {dfltCol, uvCol});
  else
    cols = choice(sucrosePaper, {[.97 .9 .9], [.9 .97 .9]}, {dfltCol, dfltCol});
  end
  for i = 1:length(yB)
    patch([x1p, x2, x2, x1p], [ymm(i), ymm(i), yB(i), yB(i)], cols{i}, 'EdgeColor', 'none');
    plot([x1, x2], [yB(i), yB(i)], 'k', 'linewidth', .5);
  end
  yM = mean(yB);
  plot([x1, x2], [yM, yM], 'Color', [.5 .5 .5], 'linewidth', .5);
  axis tight;
end

% add warning
function warn(msg)
  warnings = [warnings, msg];
end

end   % analyze_tracks

% - - - local utility functions - - -

% conditional operator
function v = choice(cond, trueV, falseV)
  if cond
    v = trueV;
  else
    v = falseV;
  end
end

% returns indexes of k elements randomly chosen from list
function [smpl, n, k] = randomSample(list, k)
  n = length(list);
  k = min(n, k);
  smpl = randperm(n, k);
end

% strjoin was added to MATLAB only in R2013a
function s = strjoin(C, delimiter)
  if isempty(C)
    s = '';
  else
    C2 = cell(2, length(C));
    C2(1,:) = C;
    C2(2,:) = {delimiter};
    s = [C2{1:end-1}];
  end
end

% converts the given hhmmss integer to seconds (e.g., 10001 -> 3601)
function s = hhmmss2s(i)
  s = round(datenum(sprintf('00000100-%06d', i),'yyyymmdd-HHMMSS')*3600*24);
end

% returns the smallest difference between the two given angles ("th1-th2")
function d = angleDiff(th1, th2)
  d = mod(th1-th2+pi, 2*pi) - pi;
end

% returns whether the given structure has the given field
% NOTE: does not work; TO DO: figure out why
function b = hasField(structName, fieldName)
  b = exist(structName, 'var') && isfield(eval(structName), fieldName);
end

% get readframe
function [readframe, nframes, fid] = getReadframe(avi)
  if ~exist('readframe_fcn')
    [readframe, nframes, fid] = get_readframe_fcn(avi);
  else
    readframe = readframe_fcn.readframe;
    nframes = readframe_fcn.nframes;
    fid = readframe_fcn.fid;
  end
end
